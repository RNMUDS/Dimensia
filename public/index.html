<!DOCTYPE html>
<html>
<head>
    <title>Particle Wave VR - Three.js</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #87cefa;
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #controls {
            position: absolute;
            bottom: 60px;
            left: 10px;
            color: #87cefa;
            font-size: 12px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #vrButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border: 1px solid #87cefa;
            background: rgba(0,0,0,0.7);
            color: #87cefa;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            z-index: 100;
            transition: all 0.3s;
        }
        #vrButton:hover {
            background: rgba(135, 206, 250, 0.2);
            border-color: #ffffff;
            color: #ffffff;
        }
        #vrButton:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js",
            "three/": "https://cdn.jsdelivr.net/npm/three@0.128.0/"
        }
    }
    </script>
</head>
<body>
    <div id="info">
        Particle Wave VR Effect<br>
        Particles: <span id="particleCount">5000</span><br>
        <span id="vrStatus">VR Not Supported</span>
    </div>
    
    <div id="controls">
        <strong>PC Controls:</strong><br>
        WASD - Move<br>
        Shift - Run<br>
        Mouse - Look around<br>
        <br>
        <strong>VR Controls:</strong><br>
        Grip - Teleport<br>
        Trigger - Change settings<br>
        Pinch - Change color/frequency
    </div>
    
    <button id="vrButton">Enter VR</button>
    
    <script type="module">
        import * as THREE from 'three';
        
        // === パーティクルウェーブのパラメータ ===
        const pc_params = {
            count: 500000,              // パーティクルの数
            spread: 200,              // パーティクルが広がる範囲

            particleSize: 0.01,        // パーティクルの大きさ
            amplitude: 1,            // 波の振幅（高さ）
            frequency: 0.2,          // 波の周波数（細かさ）
            speed: 0.2,               // 波が広がる速さ
            color: 0x87cefa          // パーティクルの色（ライトスカイブルー）
        };

        const vr_params = {
            count: 100000,              // パーティクルの数
            spread: 100,              // パーティクルが広がる範囲
            particleSize: 0.01,        // パーティクルの大きさ
            amplitude: 1,            // 波の振幅（高さ）
            frequency: 0.2,          // 波の周波数（細かさ）
            speed: 0.2,               // 波が広がる速さ
            color: 0x87cefa          // パーティクルの色（ライトスカイブルー）
        };

        // === デバイスごとのパラメータ選択 ===
        let params = pc_params; // デフォルトはPC用パラメータ
        let isVRMode = false;
        
        // VRセッション開始時にパラメータを切り替える関数
        function switchToVRParams() {
            params = vr_params;
            isVRMode = true;
            recreateParticles();
        }
        
        // PC用パラメータに戻す関数
        function switchToPCParams() {
            params = pc_params;
            isVRMode = false;
            recreateParticles();
        }
        
        // === 基本設定 ===
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 50, 300);
        
        const camera = new THREE.PerspectiveCamera(
            75, 
            window.innerWidth / window.innerHeight, 
            0.1, 
            1000
        );
        camera.position.set(0, 1.6, 5);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.xr.enabled = true; // WebXRを有効化
        document.body.appendChild(renderer.domElement);
        
        // === VRサポートチェック ===
        const vrStatusElement = document.getElementById('vrStatus');
        const customVRButton = document.getElementById('vrButton');
        
        if ('xr' in navigator) {
            navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                if (supported) {
                    vrStatusElement.textContent = 'VR Ready';
                    vrStatusElement.style.color = '#00ff00';
                    
                    // カスタムVRボタンの設定
                    customVRButton.addEventListener('click', async () => {
                        const sessionInit = {
                            optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking']
                        };
                        
                        try {
                            const session = await navigator.xr.requestSession('immersive-vr', sessionInit);
                            renderer.xr.setSession(session);
                            
                            customVRButton.textContent = 'Exit VR';
                            
                            // VRモードに入ったらVR用パラメータに切り替え
                            switchToVRParams();
                            
                            session.addEventListener('end', () => {
                                customVRButton.textContent = 'Enter VR';
                                // VRモードを終了したらPC用パラメータに戻す
                                switchToPCParams();
                                // ハンドトラッキングのメッシュをクリーンアップ
                                cleanupHandMeshes();
                            });
                        } catch (e) {
                            console.error('VRセッションの開始に失敗:', e);
                        }
                    });
                } else {
                    vrStatusElement.textContent = 'VR Not Supported';
                    vrStatusElement.style.color = '#ff0000';
                    customVRButton.disabled = true;
                }
            });
        } else {
            customVRButton.disabled = true;
        }
        
        // === VR用のカメラグループ（プレイヤーの位置を管理） ===
        const cameraGroup = new THREE.Group();
        cameraGroup.add(camera);
        scene.add(cameraGroup);
        
        // === ライティング ===
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        
        const pointLight = new THREE.PointLight(0xffffff, 1);
        pointLight.position.set(50, 50, 50);
        scene.add(pointLight);
        
        // VR空間用の追加ライト
        const vrLight = new THREE.PointLight(0x87cefa, 0.5);
        cameraGroup.add(vrLight); // カメラグループに追加してプレイヤーと一緒に移動
        
        // ハンド用のライト（より良い視認性のため）
        const handLight1 = new THREE.PointLight(0xffffff, 0.1, 2);
        handLight1.position.set(0, 0.2, 0);
        cameraGroup.add(handLight1);
        
        // === スターゲート用のシェーダー ===
        const eventHorizonVertexShader = `
            uniform float time;
            varying vec2 vUv;
            varying vec3 vPosition;
            
            void main() {
                vUv = uv;
                vPosition = position;
                
                vec3 pos = position;
                vec2 center = vec2(0.5, 0.5);
                float dist = distance(uv, center);
                
                // 波紋効果
                float ripple1 = sin(dist * 30.0 - time * 3.0) * 0.02;
                float ripple2 = sin(dist * 50.0 - time * 5.0 + 1.0) * 0.01;
                float ripple3 = cos(dist * 70.0 - time * 7.0 + 2.0) * 0.005;
                
                // 中心部は穏やか、外側は激しく
                float intensity = smoothstep(0.0, 0.5, dist);
                pos.z += (ripple1 + ripple2 + ripple3) * intensity * (1.0 - dist);
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;
        
        const eventHorizonFragmentShader = `
            uniform float time;
            uniform vec3 portalColor;
            varying vec2 vUv;
            varying vec3 vPosition;
            
            void main() {
                vec2 center = vec2(0.5, 0.5);
                float dist = distance(vUv, center);
                
                // 放射状の波紋パターン
                float angle = atan(vUv.y - 0.5, vUv.x - 0.5);
                float radialWave = sin(dist * 40.0 - time * 4.0) * 0.5 + 0.5;
                float spiralWave = sin(angle * 8.0 + dist * 20.0 - time * 3.0) * 0.5 + 0.5;
                
                // 色の計算
                vec3 color = vec3(0.0);
                
                // 中心の明るい部分
                float centerGlow = exp(-dist * 4.0) * 1.0;
                color += portalColor * 1.5 * centerGlow;
                
                // 波紋（ポータルカラーベース）
                float wavePattern = radialWave * spiralWave;
                vec3 waveColor = mix(
                    portalColor * 0.3,
                    portalColor * 0.8,
                    wavePattern
                );
                color += waveColor * (1.0 - dist * 0.7) * 0.5;
                
                // エッジの輝き
                float edgeGlow = pow(1.0 - smoothstep(0.4, 0.5, dist), 3.0);
                color += portalColor * edgeGlow * 0.8;
                
                // アルファ値
                float alpha = 1.0;
                alpha *= smoothstep(0.5, 0.48, dist);
                
                // HDR風の輝き
                color = pow(color, vec3(0.8));
                
                gl_FragColor = vec4(color, alpha);
            }
        `;
        
        // === スターゲート作成関数 ===
        function createStargate(position, scale = 1.0) {
            const gateGroup = new THREE.Group();
            gateGroup.position.copy(position);
            
            // メカニカルなリング
            const outerRingGeo = new THREE.TorusGeometry(6 * scale, 0.4 * scale, 8, 50);
            const ringMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a2e,
                metalness: 0.95,
                roughness: 0.05,
                emissive: 0x0a0a20,
                emissiveIntensity: 0.2
            });
            const outerRing = new THREE.Mesh(outerRingGeo, ringMaterial);
            gateGroup.add(outerRing);
            
            // 内側の技術的なディテール
            const detailGroup = new THREE.Group();
            for (let i = 0; i < 38; i++) {
                const angle = (i / 38) * Math.PI * 2;
                
                const chevronShape = new THREE.Shape();
                chevronShape.moveTo(0, 0);
                chevronShape.lineTo(-0.15, 0.3);
                chevronShape.lineTo(0, 0.4);
                chevronShape.lineTo(0.15, 0.3);
                chevronShape.closePath();
                
                const extrudeSettings = {
                    depth: 0.1,
                    bevelEnabled: true,
                    bevelSegments: 2,
                    bevelSize: 0.02,
                    bevelThickness: 0.02
                };
                
                const chevronGeo = new THREE.ExtrudeGeometry(chevronShape, extrudeSettings);
                const chevronMat = new THREE.MeshStandardMaterial({
                    color: 0x2d4059,
                    metalness: 0.9,
                    roughness: 0.1,
                    emissive: i % 5 === 0 ? 0x4488ff : 0x112244,
                    emissiveIntensity: i % 5 === 0 ? 0.8 : 0.3
                });
                
                const chevron = new THREE.Mesh(chevronGeo, chevronMat);
                chevron.position.x = Math.cos(angle) * 5.5 * scale;
                chevron.position.y = Math.sin(angle) * 5.5 * scale;
                chevron.position.z = -0.05;
                chevron.rotation.z = angle - Math.PI / 2;
                detailGroup.add(chevron);
            }
            gateGroup.add(detailGroup);
            
            // イベントホライズン（水面効果）のシェーダー
            const eventHorizonGeo = new THREE.CircleGeometry(5 * scale, 128);
            const eventHorizonMat = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    portalColor: { value: new THREE.Color(0x0080ff) }
                },
                vertexShader: eventHorizonVertexShader,
                fragmentShader: eventHorizonFragmentShader,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            const eventHorizon = new THREE.Mesh(eventHorizonGeo, eventHorizonMat);
            eventHorizon.position.copy(position);
            scene.add(eventHorizon);
            
            // グロー効果
            const glowGeo = new THREE.RingGeometry(4.5 * scale, 5.5 * scale, 64);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0x0080ff,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            const glowRing = new THREE.Mesh(glowGeo, glowMat);
            glowRing.position.copy(position);
            scene.add(glowRing);
            
            return { gateGroup, detailGroup, eventHorizon, eventHorizonMat, glowRing };
        }
        
        // === スターゲートを配置（8つ、スタート地点の近くに） ===
        const stargates = [];
        const gatePositions = [
            // 左側4つ
            new THREE.Vector3(-15, 5, -10),
            new THREE.Vector3(-15, 5, -20),
            new THREE.Vector3(-15, 5, -30),
            new THREE.Vector3(-15, 5, -40),
            // 右側4つ
            new THREE.Vector3(15, 5, -10),
            new THREE.Vector3(15, 5, -20),
            new THREE.Vector3(15, 5, -30),
            new THREE.Vector3(15, 5, -40)
        ];
        
        gatePositions.forEach((pos, index) => {
            const stargate = createStargate(pos, 0.5);
            // 左右のポータルを向かい合わせる
            if (index < 4) {
                // 左側のポータルは右を向く
                stargate.gateGroup.rotation.y = Math.PI / 2;
                stargate.eventHorizon.rotation.y = Math.PI / 2;
                stargate.glowRing.rotation.y = Math.PI / 2;
            } else {
                // 右側のポータルは左を向く
                stargate.gateGroup.rotation.y = -Math.PI / 2;
                stargate.eventHorizon.rotation.y = -Math.PI / 2;
                stargate.glowRing.rotation.y = -Math.PI / 2;
            }
            scene.add(stargate.gateGroup);
            stargates.push(stargate);
        });
        
        // === InstancedMesh の作成 ===
        let geometry;
        let material;
        let instancedMesh;
        let particlePositions = [];
        const dummy = new THREE.Object3D();
        
        // パーティクルを作成/再作成する関数
        function recreateParticles() {
            // 既存のメッシュがあれば削除
            if (instancedMesh) {
                scene.remove(instancedMesh);
                geometry.dispose();
                material.dispose();
            }
            
            // 新しいジオメトリとマテリアルを作成
            geometry = new THREE.SphereGeometry(params.particleSize, 8, 6);
            material = new THREE.MeshPhongMaterial({
                color: params.color,
                emissive: params.color,
                emissiveIntensity: 0.3,
                shininess: 100
            });
            
            // 新しいInstancedMeshを作成
            instancedMesh = new THREE.InstancedMesh(geometry, material, params.count);
            
            // パーティクルの位置をリセット
            particlePositions = [];
            
            // 各インスタンスの初期位置を設定
            for (let i = 0; i < params.count; i++) {
                const x = (Math.random() - 0.5) * params.spread;
                const z = (Math.random() - 0.5) * params.spread;
                
                particlePositions.push({ x, z });
                
                dummy.position.set(x, 0, z);
                dummy.scale.set(1, 1, 1);
                dummy.updateMatrix();
                
                instancedMesh.setMatrixAt(i, dummy.matrix);
            }
            
            instancedMesh.instanceMatrix.needsUpdate = true;
            scene.add(instancedMesh);
            
            // パーティクル数表示を更新
            document.getElementById('particleCount').textContent = params.count;
        }
        
        // 初回のパーティクル作成
        recreateParticles();
        
        // === VR用の地面（参照用） ===
        const floorGeometry = new THREE.PlaneGeometry(200, 200);
        const floorMaterial = new THREE.MeshBasicMaterial({
            color: 0x001122,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -10;
        scene.add(floor);
        

        // === VRコントローラーとハンドトラッキングのセットアップ ===
        // コントローラー1（右手）
        const controller1 = renderer.xr.getController(0);
        cameraGroup.add(controller1);
        
        // コントローラー2（左手）
        const controller2 = renderer.xr.getController(1);
        cameraGroup.add(controller2);
        
        // ハンドトラッキング用のハンドオブジェクト
        const hand1 = renderer.xr.getHand(0);
        const hand2 = renderer.xr.getHand(1);
        cameraGroup.add(hand1);
        cameraGroup.add(hand2);
        
        // === リアルな手のマテリアル設定 ===
        // 肌のマテリアル（Three.js r128対応）
        const skinMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xffb896,
            roughness: 0.8,
            metalness: 0.0,
            clearcoat: 0.05,
            clearcoatRoughness: 0.9,
            emissive: 0x000000,
            emissiveIntensity: 0
        });
        
        // 関節の球体を作成（関節ごとに異なる形状）
        function createJointSphere(radius = 0.008, type = 'normal', jointName = '') {
            let geometry;
            if (type === 'knuckle') {
                // ナックル（指の付け根）はより大きく、やや扁平
                geometry = new THREE.SphereGeometry(radius * 1.2, 16, 12);
                geometry.scale(1, 0.8, 1.1);
            } else if (type === 'tip') {
                // 指先は小さく、やや細長い
                geometry = new THREE.SphereGeometry(radius * 0.8, 16, 12);
                geometry.scale(0.9, 0.9, 1.1);
            } else if (type === 'wrist') {
                // 手首は横長の楕円形
                geometry = new THREE.SphereGeometry(radius, 16, 12);
                geometry.scale(1.8, 0.8, 1.2); // X軸方向に1.8倍、Y軸方向に0.8倍
            } else {
                geometry = new THREE.SphereGeometry(radius, 16, 12);
            }
            const mesh = new THREE.Mesh(geometry, skinMaterial);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }
        
        // 各関節用のメッシュとボーンラインを作成
        const jointMeshes1 = {};
        const jointMeshes2 = {};
        const boneLines1 = [];
        const boneLines2 = [];
        
        // ハンドデータ（腕の情報を含む）
        const handData1 = { forearm: null };
        const handData2 = { forearm: null };
        
        
        // 指の接続関係を定義
        const fingerConnections = [
            // 親指
            ['wrist', 'thumb-metacarpal'],
            ['thumb-metacarpal', 'thumb-phalanx-proximal'],
            ['thumb-phalanx-proximal', 'thumb-phalanx-distal'],
            ['thumb-phalanx-distal', 'thumb-tip'],
            // 人差し指
            ['wrist', 'index-finger-metacarpal'],
            ['index-finger-metacarpal', 'index-finger-phalanx-proximal'],
            ['index-finger-phalanx-proximal', 'index-finger-phalanx-intermediate'],
            ['index-finger-phalanx-intermediate', 'index-finger-phalanx-distal'],
            ['index-finger-phalanx-distal', 'index-finger-tip'],
            // 中指
            ['wrist', 'middle-finger-metacarpal'],
            ['middle-finger-metacarpal', 'middle-finger-phalanx-proximal'],
            ['middle-finger-phalanx-proximal', 'middle-finger-phalanx-intermediate'],
            ['middle-finger-phalanx-intermediate', 'middle-finger-phalanx-distal'],
            ['middle-finger-phalanx-distal', 'middle-finger-tip'],
            // 薬指
            ['wrist', 'ring-finger-metacarpal'],
            ['ring-finger-metacarpal', 'ring-finger-phalanx-proximal'],
            ['ring-finger-phalanx-proximal', 'ring-finger-phalanx-intermediate'],
            ['ring-finger-phalanx-intermediate', 'ring-finger-phalanx-distal'],
            ['ring-finger-phalanx-distal', 'ring-finger-tip'],
            // 小指
            ['wrist', 'pinky-finger-metacarpal'],
            ['pinky-finger-metacarpal', 'pinky-finger-phalanx-proximal'],
            ['pinky-finger-phalanx-proximal', 'pinky-finger-phalanx-intermediate'],
            ['pinky-finger-phalanx-intermediate', 'pinky-finger-phalanx-distal'],
            ['pinky-finger-phalanx-distal', 'pinky-finger-tip']
        ];
        
        // コントローラーのビジュアルは不要（ハンドトラッキングを使用するため）
        
        // === PC用のWASD移動制御 ===
        const moveSpeed = 0.1;
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            shift: false
        };
        
        document.addEventListener('keydown', (event) => {
            const key = event.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = true;
            }
            if (key === 'shift') {
                keys.shift = true;
            }
        });
        
        document.addEventListener('keyup', (event) => {
            const key = event.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = false;
            }
            if (key === 'shift') {
                keys.shift = false;
            }
        });
        
        function updateCameraMovement() {
            if (!renderer.xr.isPresenting) {
                const speed = keys.shift ? moveSpeed * 2 : moveSpeed;
                
                // カメラの向きを基準に移動方向を計算
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                forward.y = 0; // Y軸の移動を無効化（地面に平行に移動）
                forward.normalize();
                
                const right = new THREE.Vector3();
                right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
                
                if (keys.w) {
                    cameraGroup.position.addScaledVector(forward, speed);
                }
                if (keys.s) {
                    cameraGroup.position.addScaledVector(forward, -speed);
                }
                if (keys.a) {
                    cameraGroup.position.addScaledVector(right, -speed);
                }
                if (keys.d) {
                    cameraGroup.position.addScaledVector(right, speed);
                }
            }
        }
        
        // === VR用のテレポート機能 ===
        const teleportGeometry = new THREE.RingGeometry(0.5, 0.8, 32);
        const teleportMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.5
        });
        const teleportMarker = new THREE.Mesh(teleportGeometry, teleportMaterial);
        teleportMarker.rotation.x = -Math.PI / 2;
        teleportMarker.visible = false;
        scene.add(teleportMarker);
        
        // テレポート用のレイキャスター
        const raycaster = new THREE.Raycaster();
        const tempMatrix = new THREE.Matrix4();
        
        // テレポート用の放物線
        const arcGeometry = new THREE.BufferGeometry();
        const arcMaterial = new THREE.LineBasicMaterial({
            color: 0x00ff00,
            linewidth: 3
        });
        const teleportArc = new THREE.Line(arcGeometry, arcMaterial);
        teleportArc.visible = false;
        scene.add(teleportArc);
        
        // テレポート可能な床を作成（見えない）
        const teleportFloorGeometry = new THREE.PlaneGeometry(300, 300);
        const teleportFloorMaterial = new THREE.MeshBasicMaterial({
            visible: false
        });
        const teleportFloor = new THREE.Mesh(teleportFloorGeometry, teleportFloorMaterial);
        teleportFloor.rotation.x = -Math.PI / 2;
        teleportFloor.position.y = 0;
        scene.add(teleportFloor);
        
        // テレポートのトリガー状態
        let controller1Squeezing = false;
        let controller2Squeezing = false;
        
        // コントローラーのスクイーズイベント（グリップボタン）
        controller1.addEventListener('squeezestart', () => {
            controller1Squeezing = true;
        });
        
        controller1.addEventListener('squeezeend', () => {
            controller1Squeezing = false;
            // テレポート実行
            if (teleportMarker.visible) {
                cameraGroup.position.x = teleportMarker.position.x;
                cameraGroup.position.z = teleportMarker.position.z;
                teleportMarker.visible = false;
            }
        });
        
        controller2.addEventListener('squeezestart', () => {
            controller2Squeezing = true;
        });
        
        controller2.addEventListener('squeezeend', () => {
            controller2Squeezing = false;
            // テレポート実行
            if (teleportMarker.visible) {
                cameraGroup.position.x = teleportMarker.position.x;
                cameraGroup.position.z = teleportMarker.position.z;
                teleportMarker.visible = false;
            }
        });
        
        function updateTeleport(controller, squeezing) {
            if (squeezing && renderer.xr.isPresenting) {
                tempMatrix.identity().extractRotation(controller.matrixWorld);
                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
                
                const intersects = raycaster.intersectObject(teleportFloor);
                if (intersects.length > 0) {
                    teleportMarker.position.copy(intersects[0].point);
                    teleportMarker.position.y = 0.01; // 少し上に配置
                    teleportMarker.visible = true;
                } else {
                    teleportMarker.visible = false;
                }
            }
        }
        
        // ハンドトラッキングでのピンチ状態を追跡
        let hand1Pinching = false;
        let hand2Pinching = false;
        
        // ハンドメッシュのクリーンアップ関数
        function cleanupHandMeshes() {
            // ハンド1のクリーンアップ
            for (const jointName in jointMeshes1) {
                if (jointMeshes1[jointName]) {
                    scene.remove(jointMeshes1[jointName]);
                    jointMeshes1[jointName].geometry.dispose();
                    delete jointMeshes1[jointName];
                }
            }
            
            // ハンド2のクリーンアップ
            for (const jointName in jointMeshes2) {
                if (jointMeshes2[jointName]) {
                    scene.remove(jointMeshes2[jointName]);
                    jointMeshes2[jointName].geometry.dispose();
                    delete jointMeshes2[jointName];
                }
            }
            
            // ボーンラインのクリーンアップ
            boneLines1.forEach((line, index) => {
                if (line) {
                    scene.remove(line);
                    line.geometry.dispose();
                    boneLines1[index] = null;
                }
            });
            
            boneLines2.forEach((line, index) => {
                if (line) {
                    scene.remove(line);
                    line.geometry.dispose();
                    boneLines2[index] = null;
                }
            });
            
            // 腕のクリーンアップ
            if (handData1.forearm) {
                scene.remove(handData1.forearm);
                handData1.forearm.geometry.dispose();
                handData1.forearm = null;
            }
            
            if (handData2.forearm) {
                scene.remove(handData2.forearm);
                handData2.forearm.geometry.dispose();
                handData2.forearm = null;
            }
        }
        
        // ピンチ検出関数
        function isPinching(hand) {
            if (!hand.joints || !hand.joints['thumb-tip'] || !hand.joints['index-finger-tip']) {
                return false;
            }
            
            const thumbTip = new THREE.Vector3();
            const indexTip = new THREE.Vector3();
            
            hand.joints['thumb-tip'].getWorldPosition(thumbTip);
            hand.joints['index-finger-tip'].getWorldPosition(indexTip);
            
            const distance = thumbTip.distanceTo(indexTip);
            return distance < 0.02; // 2cm以下でピンチと判定
        }
        
        // ハンドトラッキングでのテレポート更新
        function updateHandTeleport(hand, pinching) {
            if (pinching && renderer.xr.isPresenting && hand.joints && hand.joints['index-finger-metacarpal']) {
                // 人差し指の付け根から前方にレイを飛ばす
                const origin = new THREE.Vector3();
                const direction = new THREE.Vector3();
                const quaternion = new THREE.Quaternion();
                
                hand.joints['index-finger-metacarpal'].getWorldPosition(origin);
                hand.joints['index-finger-metacarpal'].getWorldQuaternion(quaternion);
                
                // 手のひらの向きに基づいて前方向を計算
                direction.set(0, 0, -1).applyQuaternion(quaternion);
                
                // レイキャスターを設定
                raycaster.set(origin, direction);
                
                const intersects = raycaster.intersectObject(teleportFloor);
                if (intersects.length > 0) {
                    teleportMarker.position.copy(intersects[0].point);
                    teleportMarker.position.y = 0.01;
                    teleportMarker.visible = true;
                    
                    // 放物線を描画
                    const points = [];
                    const segments = 30;
                    for (let i = 0; i <= segments; i++) {
                        const t = i / segments;
                        const point = new THREE.Vector3();
                        point.lerpVectors(origin, intersects[0].point, t);
                        point.y += Math.sin(t * Math.PI) * 0.5; // 放物線の高さ
                        points.push(point);
                    }
                    
                    const positions = new Float32Array(points.length * 3);
                    for (let i = 0; i < points.length; i++) {
                        positions[i * 3] = points[i].x;
                        positions[i * 3 + 1] = points[i].y;
                        positions[i * 3 + 2] = points[i].z;
                    }
                    
                    arcGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    teleportArc.visible = true;
                } else {
                    teleportMarker.visible = false;
                    teleportArc.visible = false;
                }
            } else {
                if (!pinching) {
                    teleportArc.visible = false;
                }
            }
        }
        
        // ハンドトラッキングの更新関数
        function updateHandTracking(hand, jointMeshes, boneLines, handData) {
            if (renderer.xr.isPresenting && hand.joints) {
                // ハンドが検出されているかチェック
                let handDetected = false;
                for (const jointName in hand.joints) {
                    if (hand.joints[jointName]) {
                        handDetected = true;
                        break;
                    }
                }
                
                if (!handDetected) {
                    // ハンドが検出されていない場合は非表示
                    for (const jointName in jointMeshes) {
                        if (jointMeshes[jointName]) {
                            jointMeshes[jointName].visible = false;
                        }
                    }
                    boneLines.forEach(cylinder => {
                        if (cylinder) cylinder.visible = false;
                    });
                    if (handData.forearm) {
                        handData.forearm.visible = false;
                    }
                    return;
                }
                
                // 各関節の位置を更新
                for (const jointName in hand.joints) {
                    const joint = hand.joints[jointName];
                    
                    // 関節のメッシュがなければ作成
                    if (!jointMeshes[jointName]) {
                        let radius, type = 'normal';
                        if (jointName === 'wrist') {
                            // 手首
                            radius = 0.015;
                            type = 'wrist';
                        } else if (jointName.includes('metacarpal')) {
                            // 中手骨（手の甲の骨）
                            radius = 0.012;
                            type = 'knuckle';
                        } else if (jointName.includes('tip')) {
                            // 指先
                            radius = 0.009;
                            type = 'tip';
                        } else if (jointName.includes('proximal')) {
                            // 基節骨（第三関節・MP関節・こぶしの関節）
                            radius = 0.012;
                        } else if (jointName.includes('intermediate')) {
                            // 中節骨（第二関節・PIP関節）
                            radius = 0.01;
                        } else if (jointName.includes('distal')) {
                            // 末節骨（第一関節・DIP関節）
                            radius = 0.008;
                        } else {
                            radius = 0.008;
                        }
                        
                        const mesh = createJointSphere(radius, type, jointName);
                        scene.add(mesh);
                        jointMeshes[jointName] = mesh;
             
                    }
                    
                    // 関節の位置と回転を更新
                    const worldPosition = new THREE.Vector3();
                    const worldQuaternion = new THREE.Quaternion();
                    const worldScale = new THREE.Vector3();
                    
                    joint.getWorldPosition(worldPosition);
                    joint.getWorldQuaternion(worldQuaternion);
                    joint.getWorldScale(worldScale);
                    
                    jointMeshes[jointName].position.copy(worldPosition);
                    jointMeshes[jointName].quaternion.copy(worldQuaternion);
                    jointMeshes[jointName].scale.copy(worldScale);
                    jointMeshes[jointName].visible = true;
                    
                }
                
                // 手首から腕（前腕）を追加
                if (hand.joints['wrist']) {
                    // 腕のメッシュがなければ作成
                    if (!handData.forearm) {
                        // 腕のシリンダー（手首側を手首に合わせた楕円形に）
                        // CylinderGeometry(radiusTop, radiusBottom, height, radialSegments)
                        const forearmGeometry = new THREE.CylinderGeometry(0.015, 0.030, 0.325, 16); // 0.25 * 1.3 = 0.325
                        // 手首の楕円形に合わせてスケールを調整
                        forearmGeometry.scale(1.8, 1, 1.2);
                        const forearmMesh = new THREE.Mesh(forearmGeometry, skinMaterial);
                        forearmMesh.castShadow = true;
                        forearmMesh.receiveShadow = true;
                        scene.add(forearmMesh);
                        handData.forearm = forearmMesh;
                    }
                    
                    // 手首の位置と回転を取得
                    const wristPosition = new THREE.Vector3();
                    const wristQuaternion = new THREE.Quaternion();
                    hand.joints['wrist'].getWorldPosition(wristPosition);
                    hand.joints['wrist'].getWorldQuaternion(wristQuaternion);
                    
                    // 腕の位置を計算（手首から指の反対方向に延長）
                    // 指は通常Z軸負方向を向いているので、腕はZ軸正方向に伸びる
                    const armOffset = new THREE.Vector3(0, 0, 0.1625); // Z軸正方向（腕の長さの半分: 0.325 / 2）
                    armOffset.applyQuaternion(wristQuaternion);
                    
                    // 腕のメッシュを更新
                    handData.forearm.position.copy(wristPosition);
                    handData.forearm.position.add(armOffset);
                    
                    // 腕の回転を手首に合わせる（シリンダーはY軸方向なので90度回転が必要）
                    handData.forearm.quaternion.copy(wristQuaternion);
                    // シリンダーをZ軸方向に向ける
                    handData.forearm.rotateX(-Math.PI / 2);
                    handData.forearm.visible = true;
                }
                
                // ボーンラインを更新
                fingerConnections.forEach((connection, index) => {
                    const [joint1Name, joint2Name] = connection;
                    
                    if (hand.joints[joint1Name] && hand.joints[joint2Name]) {
                        // シリンダーがなければ作成
                        if (!boneLines[index]) {
                            // 部位ごとにシリンダーの太さを調整
                            let radiusTop = 0.004;
                            let radiusBottom = 0.004;
                            
                            // 手の甲（手首から指の付け根まで）
                            if (joint1Name === 'wrist' && joint2Name.includes('metacarpal')) {
                                // 指ごとに手の甲の太さを調整（隙間がなくなるように）
                                if (joint2Name.includes('thumb')) {
                                    radiusTop = 0.01;
                                    radiusBottom = 0.01;
                                } else if (joint2Name.includes('index')) {
                                    radiusTop = 0.01;
                                    radiusBottom = 0.01;
                                } else if (joint2Name.includes('middle')) {
                                    radiusTop = 0.010;
                                    radiusBottom = 0.01;
                                } else if (joint2Name.includes('ring')) {
                                    radiusTop = 0.01;
                                    radiusBottom = 0.01;
                                } else if (joint2Name.includes('pinky')) {
                                    radiusTop = 0.01;
                                    radiusBottom = 0.01;
                                }
                            }
                            // 中手骨から基節骨（手の甲から第三関節・こぶしの関節へ）
                            else if (joint1Name.includes('metacarpal') && joint2Name.includes('proximal')) {
                                radiusTop = 0.012;
                                radiusBottom = 0.011;
                            }
                            // 基節骨（第三関節から第二関節へ）
                            else if (joint1Name.includes('proximal') && joint2Name.includes('intermediate')) {
                                radiusTop = 0.010;
                                radiusBottom = 0.011;
                            }
                            // 中節骨（第二関節から第一関節へ）
                            else if (joint1Name.includes('intermediate') && joint2Name.includes('distal')) {
                                radiusTop = 0.008;
                                radiusBottom = 0.010;
                            }
                            // 末節骨（第一関節から指先へ）
                            else if (joint1Name.includes('distal') && joint2Name.includes('tip')) {
                                radiusTop = 0.0065;
                                radiusBottom = 0.008;
                            }
                            // 親指の特別な処理
                            else if (joint1Name.includes('thumb') && joint2Name.includes('thumb')) {
                                if (joint2Name.includes('proximal')) {
                                    radiusTop = 0.012;
                                    radiusBottom = 0.015;
                                } else if (joint2Name.includes('distal')) {
                                    radiusTop = 0.009;
                                    radiusBottom = 0.01;
                                } else if (joint2Name.includes('tip')) {
                                    radiusTop = 0.009;
                                    radiusBottom = 0.01;
                                }
                            }
                            
                            const cylinderGeometry = new THREE.CylinderGeometry(radiusTop, radiusBottom, 1, 12);
                            const cylinder = new THREE.Mesh(cylinderGeometry, skinMaterial);
                            cylinder.castShadow = true;
                            cylinder.receiveShadow = true;
                            scene.add(cylinder);
                            boneLines[index] = cylinder;
                        }
                        
                        // シリンダーの位置と回転を更新
                        const pos1 = new THREE.Vector3();
                        const pos2 = new THREE.Vector3();
                        hand.joints[joint1Name].getWorldPosition(pos1);
                        hand.joints[joint2Name].getWorldPosition(pos2);
                        
                        // 手首から中手骨への接続の場合、手首側の位置を調整
                        if (joint1Name === 'wrist' && joint2Name.includes('metacarpal')) {
                            // 各指に応じて手首の楕円形上の位置にオフセット
                            const wristQuaternion = new THREE.Quaternion();
                            hand.joints[joint1Name].getWorldQuaternion(wristQuaternion);
                            
                            let xOffset = 0;
                            let zOffset = 0;
                            if (joint2Name.includes('thumb')) {
                                xOffset = -0.018; // 親指は左側かつ前方
                                zOffset = -0.008;
                            } else if (joint2Name.includes('index')) {
                                xOffset = -0.01; // 人差し指
                                zOffset = -0.002;
                            } else if (joint2Name.includes('middle')) {
                                xOffset = 0; // 中指は中央
                                zOffset = 0;
                            } else if (joint2Name.includes('ring')) {
                                xOffset = 0.01; // 薬指
                                zOffset = -0.002;
                            } else if (joint2Name.includes('pinky')) {
                                xOffset = 0.018; // 小指は右側
                                zOffset = -0.004;
                            }
                            
                            // オフセットを手首の回転に合わせて適用
                            const offset = new THREE.Vector3(xOffset, 0, zOffset);
                            offset.applyQuaternion(wristQuaternion);
                            pos1.add(offset);
                        }
                        
                        // 中点を計算
                        const midpoint = new THREE.Vector3();
                        midpoint.addVectors(pos1, pos2).multiplyScalar(0.5);
                        
                        // 距離を計算
                        const distance = pos1.distanceTo(pos2);
                        
                        // シリンダーの位置を中点に設定
                        boneLines[index].position.copy(midpoint);
                        
                        // シリンダーの長さを調整（関節間の隙間を考慮）
                        boneLines[index].scale.y = distance * 0.9;
                        
                        // シリンダーを2点間の方向に回転
                        const direction = new THREE.Vector3();
                        direction.subVectors(pos2, pos1).normalize();
                        const quaternion = new THREE.Quaternion();
                        quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
                        boneLines[index].quaternion.copy(quaternion);
                        
                        boneLines[index].visible = true;
                        boneLines[index].frustumCulled = false;
                    }
                });
            } else {
                // VRモードでない場合は非表示
                for (const jointName in jointMeshes) {
                    if (jointMeshes[jointName]) {
                        jointMeshes[jointName].visible = false;
                    }
                }
                boneLines.forEach(cylinder => {
                    if (cylinder) cylinder.visible = false;
                });
                // 腕も非表示
                if (handData.forearm) {
                    handData.forearm.visible = false;
                }
            }
        }
        
        // パーティクル数の表示は recreateParticles() 内で行われるため、この行は削除
        
        // === アニメーションループ ===
        const clock = new THREE.Clock();
        let mouseX = 0;
        let mouseY = 0;
        
        // マウス操作（非VR時）
        document.addEventListener('mousemove', (event) => {
            if (!renderer.xr.isPresenting) {
                mouseX = (event.clientX / window.innerWidth) * (-1);
            }
        });
        
        // アニメーション関数
        function animate() {
            const time = clock.getElapsedTime() * params.speed;
            
            // スターゲートのアニメーション
            stargates.forEach((stargate, index) => {
                // シェーダーの時間更新
                stargate.eventHorizonMat.uniforms.time.value = time;
                
                // ゲートの回転
                stargate.gateGroup.rotation.z = time * 0.05 + index * 0.5;
                stargate.detailGroup.rotation.z = -time * 0.1 - index * 0.3;
                
                // グローリングのパルス
                stargate.glowRing.material.opacity = 0.15 + Math.sin(time * 3 + index) * 0.05;
                stargate.glowRing.scale.set(
                    1 + Math.sin(time * 2 + index) * 0.01,
                    1 + Math.sin(time * 2 + index) * 0.01,
                    1
                );
            });
            
            // 各パーティクルの位置を更新（x=100, z=100を中心に振動）
            const centerX = 100;
            const centerZ = 0;
            
            for (let i = 0; i < params.count; i++) {
                const pos = particlePositions[i];
                // 中心点(100, 100)からの距離を計算
                const dx = pos.x - centerX;
                const dz = pos.z - centerZ;
                const distance = Math.sqrt(dx * dx + dz * dz);
                const y = params.amplitude * Math.sin(distance * params.frequency - time);
                
                dummy.position.set(pos.x, y, pos.z);
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(i, dummy.matrix);
            }
            
            instancedMesh.instanceMatrix.needsUpdate = true;
            
            // PC用の移動を更新
            updateCameraMovement();
            
            // VRモードでない時のカメラ制御
            if (!renderer.xr.isPresenting) {
                // マウスによる視点移動（位置は移動しない）
                const targetRotationY = mouseX * Math.PI;
                const targetRotationX = -mouseY * Math.PI * 0.5;
                
                camera.rotation.y += (targetRotationY - camera.rotation.y) * 0.05;
                camera.rotation.x += (targetRotationX - camera.rotation.x) * 0.05;
            } else {
                // VRモード時のテレポート更新
                updateTeleport(controller1, controller1Squeezing);
                updateTeleport(controller2, controller2Squeezing);
                
                // ハンドトラッキングの更新
                updateHandTracking(hand1, jointMeshes1, boneLines1, handData1);
                updateHandTracking(hand2, jointMeshes2, boneLines2, handData2);
                
                // ピンチ状態の更新とテレポート処理
                const wasPinching1 = hand1Pinching;
                const wasPinching2 = hand2Pinching;
                
                hand1Pinching = isPinching(hand1);
                hand2Pinching = isPinching(hand2);
                
                // ハンド1のテレポート処理
                if (hand1Pinching) {
                    updateHandTeleport(hand1, true);
                } else if (wasPinching1 && !hand1Pinching && teleportMarker.visible) {
                    // ピンチを離したときにテレポート実行
                    cameraGroup.position.x = teleportMarker.position.x;
                    cameraGroup.position.z = teleportMarker.position.z;
                    teleportMarker.visible = false;
                    teleportArc.visible = false;
                    
                    // テレポート後にボーンラインの可視性を強制的に更新
                    boneLines1.forEach(cylinder => {
                        if (cylinder) {
                            cylinder.visible = true;
                            cylinder.frustumCulled = false;
                        }
                    });
                    boneLines2.forEach(cylinder => {
                        if (cylinder) {
                            cylinder.visible = true;
                            cylinder.frustumCulled = false;
                        }
                    });
                }
                
                // ハンド2のテレポート処理
                if (hand2Pinching) {
                    updateHandTeleport(hand2, true);
                } else if (wasPinching2 && !hand2Pinching && teleportMarker.visible) {
                    // ピンチを離したときにテレポート実行
                    cameraGroup.position.x = teleportMarker.position.x;
                    cameraGroup.position.z = teleportMarker.position.z;
                    teleportMarker.visible = false;
                    teleportArc.visible = false;
                    
                    // テレポート後にボーンラインの可視性を強制的に更新
                    boneLines1.forEach(cylinder => {
                        if (cylinder) {
                            cylinder.visible = true;
                            cylinder.frustumCulled = false;
                        }
                    });
                    boneLines2.forEach(cylinder => {
                        if (cylinder) {
                            cylinder.visible = true;
                            cylinder.frustumCulled = false;
                        }
                    });
                }
            }
        }
        
        // WebXR用のアニメーションループ
        renderer.setAnimationLoop(function() {
            animate();
            renderer.render(scene, camera);
        });
        
        // === ウィンドウリサイズ対応 ===
        window.addEventListener('resize', () => {
            if (!renderer.xr.isPresenting) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                
                // VRモードでない場合はハンドメッシュを非表示
                for (const jointName in jointMeshes1) {
                    if (jointMeshes1[jointName]) jointMeshes1[jointName].visible = false;
                }
                for (const jointName in jointMeshes2) {
                    if (jointMeshes2[jointName]) jointMeshes2[jointName].visible = false;
                }
                boneLines1.forEach(line => {
                    if (line) line.visible = false;
                });
                boneLines2.forEach(line => {
                    if (line) line.visible = false;
                });
            }
        });
        
        // コントローラーのイベントを削除（クリックで波が強くならないように）
    </script>
</body>
</html>